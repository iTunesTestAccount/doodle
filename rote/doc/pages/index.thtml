h1(logo). #d00d1e

Doodle is a Ruby library and gem for simplifying the definition of Ruby classes
by making attributes and their properties more declarative.

Doodle is eco-friendly - it does not globally modify Object, Class or Module,
nor does it pollute instances with its own instance variables (i.e. it plays nice with yaml).

Doodle has been tested with Ruby 1.8.6 and JRuby 1.1. It also has
limited support for Ruby 1.8.5. It does not yet work with Ruby 1.9 or Rubinius.

h3. features

* <a href="#initialization">initialization</a>
** using <a href="#using_positional_arguments">positional arguments</a>
** with <a href="#named_arguments">named arguments</a>
** by <a href="#block_initialization">block</a>
* <a href="#defaults">defaults</a>
* <a href="#initial_values">initial values</a>
* <a href="#validations">validation</a> at attribute and class levels
* <a href="#conversions">conversions</a> for attributes and classes
* <a href="#collectors">collectors</a> to help in defining simple DSLs
* works for <a href="#class_and_singleton_level_definitions">classes, instances and singletons</a>

Putting all this together, you can initialize objects like this:

#:code#ruby#
  event = Event "Festival" do
    date '2008-04-01'
    place "The muddy field"
    place "Beer tent" do
      event "Drinking"
    end
  end

  pp event
  # >> #<Event:0x111dd4c
  # >>  @date=#<Date: 4909115/2,0,2299161>,
  # >>  @locations=
  # >>   [#<Location:0x1117be0 @events=[], @name="The muddy field">,
  # >>    #<Location:0x1114148
  # >>     @events=[#<Event:0x11115b0 @locations=[], @name="Drinking">],
  # >>     @name="Beer tent">],
  # >>  @name="Festival">
#:code#

from a class definition like this:

#:code#ruby#
require 'rubygems'
require 'date'
require 'pp'
require 'doodle'

class Location < Doodle
  has :name, :kind => String
  has :events, :collect => :Event
end

class Event < Doodle
  # or if you want to inherit from another class
  include Doodle::Core

  has :name, :kind => String
  has :date do
    kind Date
    default { Date.today }
    must 'be >= today' do |value|
      value >= Date.today
    end
    from String do |s|
      Date.parse(s)
    end
  end
  has :locations, :collect => {:place => "Location"}
end
#:code#

h2. installation

On Linux or Mac OS X:

#:code#ruby#
  $ sudo gem install doodle  
#:code#

On Windows:

#:code#ruby#
  C:\> gem install doodle
#:code#

h2. initialization

#:code#ruby#
  class Event < Doodle
    has :date
  end
#:code#

With this declaration, you can now initialize an instance of Event in the following ways.

h3. using positional arguments

#:code#ruby#
  event = Event Date.today
#:code#

h3. named arguments

#:code#ruby#
  event = Event :date => Date.today
#:code#

h3. block initialization

#:code#ruby#
  event = Event do
    date Date.today
  end
#:code#

Of course, if you insist on typing @new@, you can:

#:code#ruby#
  event = Event.new(:date => Date.today)
#:code#

h2. defaults

Doodle assumes that attributes specified without defaults or initial
values (see below) are required. If you try to initialize an instance
without providing values for all required attributes, Doodle will
raise an exception. For example:

#:code#ruby#
  class Event < Doodle
    has :date
  end

  event = Event()
  # or
  event = Event.new
#:code#

will result in:

#:code#ruby#
  ArgumentError: #<Event:0x72b118> missing required attribute 'date'
#:code#

To specify a default, use the @default@ option:

#:code#ruby#
  class Event < Doodle
    has :date, :default => Date.today
  end
#:code#

Now we can create an Event without specifying a date:  

#:code#ruby#
  event = Event()
  => #<Event:0x71343c>  
  event.date
  => #<Date: 4909061/2,0,2299161>
#:code#

You can of course override the default on initialization or later:

#:code#ruby#
  event = Event(:date => Date.new(2008, 03, 01))
  => #<Event:0x7036e0 @date=#<Date: 4909053/2,0,2299161>>
  event.date = Date.new(2008, 03, 05)
  => #<Date: 4909061/2,0,2299161>
#:code#

Note that if you do not specify a value for an attribute with a
default, no instance variable is created.

<blockquote> 
Side note: to use the class method constructor syntax
with other classes, include @Doodle::Factory@:

#:code#ruby#
  class Date
    include Doodle::Factory
  end
#:code#

You can now write:

#:code#ruby#
  date = Date(2008, 03, 01)
#:code#
</blockquote>

With the default specified as above, the @date@ attribute will take on
the value current when the class is defined.  If you want the default
value to be recalculated every time, use a Proc object or block as the default
value.

#:code#ruby#
  class Event < Doodle
    has :time, :default => proc { Time.now }
  end
  # or
  class Event < Doodle
    has :time do
      default { Time.now }
    end
  end

  event.time
  => Wed Mar 05 14:44:01 +0000 2008
  event.time
  => Wed Mar 05 14:44:03 +0000 2008
#:code#

This becomes more useful when you have dependent attributes, as in this example:

#:code#ruby#
  class Event < Doodle
    has :start_date, :default => Date.today
    has :end_date, :default => proc { start_date + 1 }
  end
  
  event.start_date.to_s
  => "2008-03-05"
  event.end_date.to_s
  => "2008-03-06"
#:code#

h2. initial values

Sometimes, you don't want _default_ values set when the _class_ is
_defined_ or recalculated every time. Instead you want _initial_ values which
are set when the _object_ is _instantiated_. Also, default values are
fine for simple scalar objects, but can cause problems with aggregates
such as Arrays because you end up sharing them among all instances:

#:code#ruby#
  class Event < Doodle
    has :locations, :default => []
  end

  e1 = Event()
  e2 = Event()
  e1.locations.object_id == e2.locations.object_id
  => true
#:code#

In these cases, use @init@ instead of @default@:

#:code#ruby#
  class Event < Doodle
    has :locations, :init => []
  end

  e1 = Event()
  e2 = Event()
  e1.locations.object_id == e2.locations.object_id
  => false
#:code#

Internally, Doodle copies the @init@ value by cloning it. Unlike
@default@, @init@ _does_ create an instance variable.

However, we can set still the @date@ attribute to any value we like.

#:code#ruby#
  event = Event :start_date => "Hello"
  event.start_date
  => "Hello"
  event.end_date
  => TypeError: can't convert Fixnum into String
#:code#

Hmmm... that doesn't seem right. We can restrict the kinds of values
the @date@ attribute will accept with validations.

h2. validations

h3. by kind

#:code#ruby#
  class Event < Doodle
    has :start_date, :kind => Date
  end
#:code#

Doodle uses @kind_of?@ to test the value, so @kind@ can be set to any Module
(e.g. Enumerable), Class or superclass that makes sense for your application.

If you now try to initialize Event#date with something that isn't a Date:

#:code#ruby#
  event = Event.new(:date => "Hello")
#:code#

you'll get a Doodle::ValidationError exception:

#:code#ruby#
  date must be Date - got String("Hello") (Doodle::ValidationError)
#:code#

h3. specific validations with @must@

To specify a validation on an attribute, use @must@ inside the attribute's definition block:

#:code#ruby#
  class Event < Doodle
    has :start_date, :kind => Date do
      must "be >= today" do |value|
        value >= Date.today
      end
    end
  end

  event = Event :start_date => Date.today
  event.start_date = Date.parse('2001-01-01')
  =>  start_date must be >= today - got Date(#<Date: 4903821/2,0,2299161>) (Doodle::ValidationError)
#:code#

The @must@ block should return true if the value is valid, false
otherwise. A failed validation will raise a Doodle::ValidationError
exception.

Attribute validations happen before the instance variable is changed.

You can also specify validations for the object as a whole:

#:code#ruby#
  class Event < Doodle
    has :start_date, :kind => Date do
      must "be >= today" do |value|
        value >= Date.today
      end
    end
    has :end_date, :kind => Date do
      default { start_date }
    end
  
    must "have end_date >= start_date" do
      end_date >= start_date
    end
  end

  event = Event :start_date => Date.today
  event.end_date = Date.parse('2001-01-01')
  =>  #<Event:0x657ed0 @start_date=#<Date: 4909061/2,0,2299161>, @end_date=#<Date: 4903821/2,0,2299161>> must have end_date >= start_date (Doodle::ValidationError)
#:code#

Note that you don't need to project the value into the block but you
can if you like - its value is the object instance itself.

Object level validations occur after all instance variables have been
set.

h3. validating data loaded from a yaml source

YAML::load sets an object's instance variables directly, bypassing its
attribute accessors. In a Doodle context, this means that loading from
a yaml source bypasses attribute validations. You can apply
validations 'manually' by using the @validate!@ method (the
exclamation mark denotes that this method can raise an exception). For
convenience, @validate!@ returns the validated object on success, so
you can get a validated object from a yaml source using the following:

#:code#ruby#
  foo = YAML::load(yaml_source).validate!
#:code#

The following will raise an exception, complaining that 'name' is missing:

#:code#ruby#
  require "rubygems"
  require "doodle"
  require "yaml"
  class Foo < Doodle
    has :name
    has :date
  end
  str = %[
  --- !ruby/object:Foo
  date: 2000-07-01
  ]
  # load from string
  foo = YAML::load(str).validate!
  # => #<Foo:0x10c4cb0> missing required attribute 'name' (ArgumentError)
#:code#

h2. conversions

Even when you want to restrict an attribute to a particular kind, it
is often convenient to allow initialization from values that can be
converted to the target type. To do this in Doodle, use the @from@
method inside an attribute's definition block:

#:code#ruby#
  class Event < Doodle
    has :start_date, :kind => Date do
      from String do |value|
        Date.parse(value)
      end
    end
    has :end_date, :kind => Date  do
      from String do |value|
        Date.parse(value)
      end
    end
  end
  event = Event '2008-03-05', '2008-03-06'
  event.start_date.to_s   # => "2008-03-05"
  event.end_date.to_s     # => "2008-03-06"
  event.start_date = '2001-01-01'
  event.start_date        # => #<Date: 4903821/2,0,2299161>
  event.start_date.to_s   # => "2001-01-01"
#:code#

You can pass multiple classes or modules to @from@ - it's up to you to
ensure that it makes sense to do so. For example:

#:code#ruby#
  from Symbol, String do |name|
    Event(:name => name.to_s)
  end
#:code#

@from@ also works on the class level:

#:code#ruby#
  class Event < Doodle
    ...
    from String do |value|
      args = value.split(' to ')
      new(*args)
    end
  end
  event = Event.from '2008-03-05 to 2008-03-06'
  event.start_date.to_s   # => "2008-03-05"
  event.end_date.to_s     # => "2008-03-06"
#:code#

Note: the class level interface to @from@ may change in a future version.

h2. collectors

Collectors provide a means to define a convenience method you can use to add items
to a collection. For example:

#:code#ruby#
  class Location < Doodle
    has :name
  end
  class Event < Doodle
    has :locations, :init => [], :collect => Location
  end
  
  event = Event do
    location "Stage 1"
    location "Stage 2"
  end
#:code#

In the example above, we want @locations@ to be an array of @Location@
objects. Using the @:collect => Location@ option defines a method
called @location@ (derived from the class name). Each time the
@location@ method is called a new @Location@ object is added to the
@locations@ array

You can leave out the @:init@ option if all you want is to collect
into an array - doodle will supply one for you. Otherwise, you need to
supply an Enumerable that provides the @<<@ method.

To use a specific name for the collecting method, pass a hash
containing @{:method_name => ClassName}@ to the @collect@ option like this:

#:code#ruby#
    has :locations, :collect => {:place => Location}
    ...
    event = Event do
      place "Stage 1"
      place "Stage 2"
    end
#:code#

@ClassName@ can be a ClassConstant, a :Symbol or a "String".

Finally, if you don't want to restrict the value to a particular
class, you can just specify a method name:

#:code#ruby#
    has :locations, :collect => :place
    ...
    event = Event do
      place "Stage 1"
      place 42
    end
#:code#

h2. class and singleton level definitions

You can also use @has@ for class attributes:

#:code#ruby#
  class Foo < Doodle
    class << self
      has :doc, :default => "This is the Foo class"
    end
  end
#:code#

or singleton instances:

#:code#ruby#
  class Foo < Doodle
    class << self
      has :doc, :default => "This is the Foo class"
    end
  end
  
  foo = Foo.new
  class << foo
    has :special, :default => 'This object is special'
  end
  p foo.special
  # => 'This object is special'
#:code#

h2. links

* "Rubyforge project":http://rubyforge.org/projects/doodle
* "Forum":http://rubyforge.org/forum/?group_id=5159
* "Bug reports":http://rubyforge.org/tracker/?atid=19938&group_id=5159&func=browse
